# 内核驱动开发
<!-- TOC -->

1. [内核驱动开发](#内核驱动开发)
    1. [内核简介](#内核简介)
    2. [Linux内核源代码](#linux内核源代码)
        1. [目录结构：](#目录结构)
            1. [arch目录](#arch目录)
            2. [documentation目录](#documentation目录)
            3. [drivers目录](#drivers目录)
            4. [include目录](#include目录)
            5. [fs目录](#fs目录)
            6. [net目录](#net目录)
        2. [souceinsight代码工程管理](#souceinsight代码工程管理)
    3. [内核配置与编译](#内核配置与编译)
        1. [配置内核](#配置内核)
            1. [为什么要配置内核？](#为什么要配置内核)
            2. [如何配置内核](#如何配置内核)
            3. [配置内核结果](#配置内核结果)
        2. [编译内核](#编译内核)
            1. [编译内核（x86）](#编译内核x86)
            2. [编译内核模块](#编译内核模块)
            3. [制作init ramdisk](#制作init-ramdisk)
        3. [安装内核](#安装内核)
        4. [清理内核](#清理内核)
    4. [内核模块开发](#内核模块开发)
        1. [什么是内核模块？](#什么是内核模块)
        2. [内核模块设计](#内核模块设计)
2. [define DEFAULT_MESSAGE_LOGLEVEL 4](#define-default_message_loglevel-4)

<!-- /TOC -->
## 内核简介
- Linux系统架构
    - 用户空间
    - 内核空间
- Linux内核结构
    - SCI system call interface 系统调用接口
        - SCI 层为用户空间提供了一套标准的系统调用函数来访问Linux内核，搭起了用户空间到内核空间的桥梁。
    - MM memory management 内存管理
        - 内存管理的主要作用是控制多个进程安全地共享内存区域。
    - PM process management 进程管理
        - 进程管理的重点是创建进程（fork、exec），停止进程（kill、exit），并控制它们之间的通信（signal 或者 POSIX 机制）。进程管理还包括控制活动进程如何共享CPU，即进程调度。
    - ARCH architecture dependent code 底层相关代码，比如CPU
    - NS Network stack 网络协议栈
        - 内存协议栈为Linux提供了丰富的网络协议实现。
    - DD device drivers 设备驱动（内核大概有70%代码是设备驱动相关的）
        - linux内核中有大量代码都在设备驱动程序中，他们控制特定的硬件设备。
    - VFS virtual file system 虚拟文件系统
        - VFS虚拟文件系统隐藏各种文件系统的具体细节，为文件操作提供统一的结构。

现代CPU通常实现了不同的工作模式，以ARM为例，实现了7种工作模式：
- 用户模式（usr）
- 快速中断(fiq)
- 外部中断(irq)
- 管理模式（svc）
- 数据访问中止(abt)
- 系统模式(sys)
- 未定义指令异常(und)

Linux由用户空间和内核空间两部分组成。

X86也实现了4个不同的级别：Ring0—Ring3。Ring0下，可以执行特权指令，可以访问IO设备等，在Ring3则有很多限制。Linux系统利用了CPU的这一特性，使用了其中的两级来分别运行Linux内核与应用程序，这样使操作系统本身得到充分的保护。

例如：如果使用X86，用户代码运行在Ring3，内核代码运行在Ring0。

内核空间与用户空间是程序执行的两种不同状态，通过系统调用和硬件中断能够完成从用户空间到内核空间的转移。


## Linux内核源代码

下载：http://mirrors.163.com/kernel/

### 目录结构：
下载的压缩包禁止在windows（大小写不区分，导致文件丢失）

Linux内核源代码采用树形结构进行组织，非常合理地把功能相关的文件都放在同一个子目录下，使得程序更具可读性。

#### arch目录
arch是architecture的缩写。内核所支持的每一种CPU体系，在该目录下都有对应的子目录。每个cpu子目录，又进一步分解为boot，mm，kernel等子目录，分别包含系统引导、内存管理、系统调用。

x86_64 英特尔CPU及与之兼容体系结构的子目录
- boot 引导程序
    - compressed 内核解压缩
- tools 生成压缩内核映像的程序
- kernel 相关内核特性实现方式，如信号处理，时钟处理
- lib 硬件相关工具函数

#### documentation目录
内核的文档

#### drivers目录
设备驱动程序

#### include目录

内核所需要的头文件，与平台无关的头文件在include/linux子目录下，与平台相关的头文件则放在相对应的子目录下。

#### fs目录

存放各种文件系统的实现代码。每个子目录对应一种文件系统的实现，公用的源程序用于实现虚拟文件系统vfs。

- devpts  /dev/pts虚拟文件系统
- ext2 第二扩展文件系统
- fat MS的fat32文件系统
- isofs ISO9660光盘cd-rom上的文件系统

#### net目录
网络协议的实现代码
- 802 802无线通讯协议核心支持代码
- appletalk 与苹果系统联网的协议
- ax25 ax25无线internet协议
- bridge 桥接设备
- ipv4 IP协议族V4版32位寻址模式
- ipv6 IP协议族V6版

### souceinsight代码工程管理

1. 新建项目
2. 导入文件，从samba映射盘中导入（因为不能直接在windows下解压）
3. 添加汇编 Option .s .S
4. 移除arch下除arm和x86的文件，移除include下的Xen
5. 同步，查看函数联系

## 内核配置与编译
代码如何转化为烧写或安装到硬件平台中的系统映像的？
- bootloader
- ⭐内核映像 2M左右 
- 文件系统映像

### 配置内核
#### 为什么要配置内核？
- 硬件的需求 x86
- 软件的需求 ipv6

选出需要的，去掉不要的！

#### 如何配置内核
- make config 基于文本模式的交互式配置, 在解压后的内核目录顶层运行，即在有Makefile的目录中。
- 或者 make menuconfig 基于文本模式的菜单型配置

使用make menuconfig 配置内核
- <*> 所有功能合并为zImage内核映像文件，运行在内存中
- <M> 内核模块，平时放入硬盘文件夹中, 当模块需要时会调入内存运行
- < > 不选择该功能

#### 配置内核结果

配置完成后，结果保存在隐藏文件.config中。

常用配置思路：
1. 使用内核配置文件简化配置：
    - 已经安装的系统 /boot/config-2.6.32-754.el6.i686
        1. cp /boot/config-2.6.32-754.el6.i686 /usr/src/linux-2.6.39
        2. make menuconfig --> load an Alternate Configuration File， 装载完成后再按需修改
    - 内核配置通常在一个已有的配置文件基础上，通过修改得到新的配置文件，Linux内核提供了一系列可供参考的内核配置文件，位于Arch/$cpu/configs/
2. 不知道的项，默认即可

### 编译内核
> 内核升级
#### 编译内核（x86）
即编译<*>文件

- make zImage 新的版本内核已经不支持
- 或者 make bzIamge 优先使用该命令

区别：在X86平台，zImage只能用于小于512KB的内核，否则出现错误，一般内核都大于512KB.

编译时如需获取详细编译信息，可使用：
- make zImage V=1
- make bzImage V=1

大概10分钟左右的编译时间，编译好的内核为arch/$cpu/boot/bzImage

#### 编译内核模块
即编译<M>文件

- make modules 编译内核模块
- make modules_install 移动内核模块
    
编译步骤：
1. 编译内核模块，编译好内核模块为.ko文件，散落在源代码各目录下；
2. 将编译好的内核模块，从内核源代码目录移动至/lib/modules/$version/下，为打包做好准备

时长大约：1个小时。

#### 制作init ramdisk
所有文件打包操作

方法：mkinitrd initrd-$version $version

mkinitrd 打包文件名（名字也可以自己取） 打包目录（会自动寻找/lib/modules/下的目录）； 该命令执行无特定目录要求，会在当前目录下产生一个打包文件

例如 mkinitrd initrd-2.6.32 2.6.32

NOTE: $version 可以通过查询/lib/modules下的目录得到。

### 安装内核

1. cp arch/x86/boot/bzImage /boot/vmlinuz-$version
2. cp initrd-$version /boot/
3. 修改/etc/grub.conf, 从title开始4yy,p

```
default=0
timeout=5
splashimage=(hd0,0)/boot/grub/splash.xpm.gz
hiddenmenu
title CentOS 6 (2.6.32-754.el6.i686)
         root (hd0,0)
         kernel /boot/vmlinuz-2.6.32-754.el6.i686 ro root=UUID=dd4494f6-210f-4f39-aa29-1f5a8    4868dc0 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkerne    l=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
         initrd /boot/initramfs-2.6.32-754.el6.i686.img

title CentOS 6 (2.6.39)
         root (hd0,0)
         kernel /boot/vmlinuz-2.6.39 ro root=UUID=dd4494f6-210f-4f39-aa29-1f5a8    4868dc0 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkerne    l=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
         initrd /boot/initrd-2.6.39
```
grub可以引导多系统，在开机倒计时可以选择第二个内核。

系统组成
- 内核——内存
- 用户空间/文件系统——硬盘/开发板的flash


### 清理内核

编译过程中产生了哪些文件
- 配置 .config
- 编译 
    - 编译内核，中间文件.o——>bzImage; 
    - 编译模块，中间文件.o——>.ko文件

清理命令
- make clean 只清理.o文件，源文件顶层目录执行命令
- 或者 make distclean 同时清理.o文件和.config文件


## 内核模块开发

1. 什么是内核模块
2. 内核模块设计
    1. 主体部分设计
    2. 编译内核模块
    3. 安装/卸载内核模块
    4. 可选项使用
        1. 模块声明
        2. 模块参数
        3. 符号输出
3. 内核打印

### 什么是内核模块？
Linux内核的整体结构非常庞大，其中包含的组件也非常多，如何使用这些组件呢？方法1：把所有组件都编译进内核文件，即zImage或者bzImage，但这样会导致一个问题：内核文件过大，占用内存过多。

有没有一种机制能让内核文件本身并不包含某组件，而是在该组件需要被使用时，动态地添加到正在进行的内核中呢？

内核模块具有以下特点
- 模块**本身并不被编译进内核文件**（zImage或者bzImage）
- 可以根据需求，**在内核运行期间动态的安装或卸载**

### 内核模块设计

范例-helloworld

```C

#include <linux/init.h>
#include <linux/module.h>

static int hello_init(void)
{
    printk(KERN_WARNING"Hello, world!\n");
    return 0;
}

staic void hello_exit(void)
{
    printk(KERN_INFO"Goodbye, world!\n");
}

module_init(hello_int);
module_exit(hello_exit);

```

使用makefile编译内核模块

安装与卸载
- 安装 insmod hello.ko
- 卸载 rmmod hello
- 查看 lsmod

模块可选信息
1. 模块申明
2. 模块参数
3. 符号输出

模块申明
1. MODULE_LICENSE("遵守的协议")
    - 申明该模块遵守的许可证协议，如GPL，GPL v2等
2. MODULE_AUTHOR("作者")
    - 申明模块的作者
3. MODULE_DESCRIPTION("模块的功能描述")
    - 申明模块的功能
4. MODULE_VERSION("V1.0")
    - 申明模块的版本

添加内核模块申明

在应用程序中，int main(int argc, char** argv), argc表示命令行输入的参数个数，argv中保存输入的参数

1.那么内核模块中可以通过命令行输入参数么？ 可以

2.参数如何传入，传入保存在哪里？

通过宏module_param指定保存模块参数的变量。模块参数用于在内核加载模块时传递参数给模块。 module_param(name,type,perm)

name: 变量的名称
type: 变量类型，bool：布尔型 int：整型 charp：字符串型
perm：访问权限。 S_IRUGO:读权限 S_IWUSR:写权限

例：
```C
int a = 3;
char *st;
module_param(a,int,S_IRUGO);
module_param(st,charp,S_IRUGO);
```

使用模块参数

符号导出
什么是内核符号？
为什么要导出模块中的内核符号？

内核符号的导出使用宏
EXPORT_SYMBOL(符号名)
EXPORT_SYMBOL_GPL(符号名)
说明： 其中EXPORT_SYMBOL_GPL只能用于包含GPL许可证的模块。

导出内核符号
对比应用程序，内核模块具有以下不同:
1. 应用程序是从头(main)到尾执行任务，执行结束后从内存中消失。
2. 内核模块的初始化函数结束时，模块仍然存在于内核中，直到卸载函数被调用，模块才从内核中消失。

内核打印
printk是内核中出现最频繁的函数之一，通过将printk与printf对比，将有助于理解。

- printk在内核中使用，printf在应用程序中使用
- printk允许根据严重程度，通过附加不同的“优先级”来对消息分类。

在<linux/kernel.h>中定义了8种记录级别。按照优先级递减的顺序分别是：
KERN_EMERG “<0>” 用于紧急消息,常常是那些崩溃前的消息。
KERN_ALERT “<1>” 需要立刻行动的消息。
KERN_CRIT “<2>” 严重情况。
KERN_ERR “<3>” 错误情况
KERN_WARNING “<4>” 有问题的警告
KERN_NOTICE “<5>” 正常情况,但是仍然值得注意
KERN_INFO “<6>” 信息型消息
KERN_DEBUG “<7>” 用作调试消息

没有指定优先级的printk默认使用DEFAULT_MESSAGE_LOGLEVEL优先级，它是一个在kernel/printk.c中定义的整数。

#define DEFAULT_MESSAGE_LOGLEVEL 4
/* KERN_WARNING */

通过优先级控制消息是否打印到屏幕


