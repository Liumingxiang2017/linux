# 内核编译及系统裁剪

内核设计风格

RedHat, SUSE
核心：动态加载 内核模块
内核：/lib/modules/“内核版本号命令的目录”/
vmlinuz-2.6.32
/lib/modules/2.6.32/

RedHat5: ramdisk-->initrd
RedHat6: ramfs-->initramfs




	单内核：Linux (LWP)
		核心：ko(kernel object)
		
		
		
		so()
		
	微内核：Windows, Solaris (线程)

chroot: chroot /PATH/TO/TEMPROOT [COMMAND...]
	chroot /test/virrrot  /bin/bash
	
ldd /PATH/TO/BINARY_FILE：显示二进制文件所依赖的共享库




MBR（bootloader）--> Kernel --> initrd(initramfs) --> (ROOTFS) --> /sbin/init(/etc/inittab)
	/etc/inittab, /etc/init/*.conf
	upstart
	
init /etc/inittab
id:runlevels:action:process

id:5:initdefault:

si::sysinit:/etc/rc.d/rc.sysinit
OS初始化

l0:0:wait:/etc/rc.d/rc 0
	rc0.d/
		K*
			stop
		S*
			start
			
/etc/rc.d/init.d, /etc/init.d

服务类脚本：
	start
	
	SysV： /etc/rc.d/init.d
		start|stop|restart|status
		reload|configtest

chkconfig 		


chkconfig: runlevels SS KK			  当chkconfig命令来为此脚本在rc#.d目录创建链接时，runlevels表示默认创建为S*开头的链接，-表示没有级别默认为S*开头的链接；除此之外的级别默认创建为K*开头的链接；

S后面的启动优先级为SS所表示的数字；K后面关闭优先次序为KK所表示的数字；
description: 用于说明此脚本的简单功能； \, 续行

chkconfig --list： 查看所有独立守护服务的启动设定；独立守护进程！

chkconfig --list SERVICE_NAME

chkconfig --add SERVICE_NAME

chkconfig --del SERVICE_NAME

chkconfig [--level RUNLEVELS] SERVICE_NAME {on|off}
如果省略级别指定，默认为2345级别；


样例脚本：

```shell
#!/bin/bash
#
# chkconfig: 2345 77 22
# description: Test Service
# 
LOCKFILE=/var/lock/subsys/myservice

status() {
  if [ -e $LOCKFILE ]; then
    echo "Running..."
  else
    echo "Stopped."
  fi
}

usage() {
  echo "`basename $0` {start|stop|restart|status}"
}

case $1 in
start)
  echo "Starting..." 
  touch $LOCKFILE ;;
stop)
  echo "Stopping..." 
  rm -f $LOCKFILE &> /dev/null
  ;;
restart)
  echo "Restarting..." ;;
status)
  status ;;
*)
  usage ;;
esac
```

/etc/rc.d/rc.local：系统最后启动的一个服务，准确说，应该执行的一个脚本；

/etc/inittab的任务：

1. 设定默认运行级别；
2. 运行系统初始化脚本；
3. 运行指定运行级别对应的目录下的脚本；
4. 设定Ctrl+Alt+Del组合键的操作；
5. 定义UPS电源在电源故障/恢复时执行的操作；
6. 启动虚拟终端(2345级别)；
7. 启动图形终端(5级别)；

守护进程的类型：

- 独立守护进程
- xinetd：超级守护进程，代理人  
           瞬时守护进程：不需要关联至运行级别

内核由核心和内核模块两部分组成：

- 核心：/boot/vmlinuz-version
- 内核模块（ko文件）: /lib/modules/version/

## 内核基本知识

### 内核设计风格有两种：

- 单内核

所谓的单内核就是把它从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空上。因此单内核通常以单个静态二进制文件的形式存放于磁盘中。所有内核服务都在这样的一个大核地址空间上运行。内核之间的通信是微不足道的，因为大家都运行在内核态，并身处同一地址空上，所以内核可以直接调用函数。

支持单内核模式的人认为单内核具有简单和性能高的特点。大多数的Unix系统都设计为单内核。Linux也是一个单内核，也就是说，Linux内核运行在单独的内核地址空间上。

- 微内核

微内核并不作为一个单独的大过程来实现，微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器都运行在用户空间。所有的服务器都保持独立并运行在各自的地址空间上。因此就不能像单内核那样直接调用函数，而是通过IPC机制互通消息，互换“服务”。服务器的各自独立，有效地避免了一个服务器的失效祸及另一个。同样，模块化的系统允许一个服务器为了另一个服务器而换出。

IPC机制的开销多于函数调用，又因为会涉及内核空间与用户空间的上下文切换，因此，消息传递需要一定的周期，而单内核中简单的函数调用没有这些开销。所以，目前实际应用的基于微内核的系统都让大部分或全部服务器位于内核中，这样就可以直接调用函数，消除频繁的上下文切换同。

Windows NT内核（Windows XP、Windows Vista、Windows 7)和Mach（Mac OS X 的组成部分）都是微内核结构。

比较与总结：

Unix内核通常需要硬件系统提供页机制（MMU）来管理内存。这种页机制可以加强对内存空间的保护，确保每个进程都可以运行在不同的虚地址空间中。
早期的Linux也必须要有MMU支持，后期就不用了，这时的Linux已经可以运行在没MMU的小型嵌入系统上。

linux属于单内核，但是采用了微内核的设计思想，即引入模块化设计；使得内核可以很小，但必要时可以装载必要的模块。

Linux还积极汲取了微内核的优点：模块化设计、抢占式内核、支持内核线程、动态装载内核模块的能力。Linux还避免了微内核的性能损失缺陷，让所有事情都运行于内核态，直接调用函数，无须消息传递。

装载内核模块的命令：

- insmod
- modprobe

内核下载官网：www.kernel.org，最新稳定版为5.5.1，其数字意义分别为主版本号.次版本号.修正号。

2.5版本以前，次版本号为偶数是，该版本为稳定版；次版本号为奇数时，该版本为开发版。

2.6以后，比如2.6.17为稳定版时，分两条线

- 修订版： 均为稳定版本，比如2.6.17.1即主版本号.次版本号.修正版.次修正版
- 测试版： 用于修复bug，增加测试功能。比如2.6.18-rc1 （release candidate）,主版本号.次版本号.(修正号＋1)-rcN，N为1,2,3...等，直到新的稳定版2.6.18

查看内核版本号的方法是 uname -r， 内核的核心/boot/vmlinuz-version的版本号是rpm自身的发行号。


内核运行的是内核空间，但用户可以和内核打交道。用户访问空间、监控内核的方式是通过两个目录/proc, /sys。通过用户空间执行命令可以修改内核丰富的特性，实际就是修改/proc和/sys下的文件。/proc和/sys是伪文件系统，该文件系统实际是不存在的，其文件通常是内核的某个参数。在运行时修改内核就必须通过这两个目录。

/proc目录大多是只读的，只有一个目录除外，即/proc/sys: 此目录中的文件很多是可读写的。意味着修改文件的内容可以修改内核的运行特性。

/sys目录某些文件也可写，可以修正硬件工作属性。

比如：

- /proc/sys/vm/swappiness 表示在多大程度上更倾向于使用交换内存；

- /proc/sys/vm/drop_caches文件接收0、1、2这3个值，当值为1时表示清空free -m命令得出的buffers和cached内的数据，但这些都不是文件，不可以用vim打开，要想写数据是要使用echo 1 > /proc/sys/vm/drop_caches

- /proc/sys/kernel/hostname文件值，用cat /proc/sys/kernel/hostname可以查看，就是当前主机名。

- /proc/sys/net/ipv4/ip_forward，是否可以把本地当路由器来用，cat查看值为0，表示不启动，1表示启用。

```shell
vim /etc/sysctl.conf
# 修改内容
net.ipv4.ip_forward = 1
cat /proc/sys/net/ipv4/ip_foward
```

### 设定内核参数值的方法

- 使用echo加重定向的方式，echo VALUE > /proc/sys/TO/SOMEFILE
- sysctl专门用于控制/proc/sys下面某个值得，比如sysctl -w kernel.hostname=HOSTNAME,变量名的/proc/sys不用写了，只需要写/proc/sys下的目录.再下一级目录

上面两种方法能立即生效，但无法永久有效；

如果想永久有效，需要编辑/etc/sysctl.conf，但是无法立即生效。这是/etc/rc.d/rc.sysinit需要完成的任务之一，即根据/etc/sysctl.conf文件来设定内核参数。

修改文件完成之后，执行如下命令可立即生效：sysctl -p：通知内核重读文件，将立刻重设内核参数

sysctl -a: 显示所有内核参数及其值

### 内核模块管理

- lsmod: 查看当前系统装载了哪些模块

  - snd_ac97_codec 声卡驱动程序
  - pcnet32 网卡驱动程序，vmvare虚拟出来的网卡都是pcnet32

- modprobe MOD_NAME：装载某模块，不需要路径，只需要内核模块名，会自动到/lib/modules下去查找
- insmod /PATH/TO/MODULE_FILE: 装载模块,必须指定模块路径。

- modprobe -r MOD_NAME: 卸载某模块
- rmmod MOD_NAME 移除模块

- modinfo MOD_NAME: 查看模块的具体信息

- depmod /PATH/TO/MODILES_DIR 指定目录生成模块依赖关系表

```shell
[root@lmxlab ~]# modinfo video
# 模块路径
filename:       /lib/modules/2.6.32-754.el6.i686/kernel/drivers/acpi/video.ko
license:        GPL
description:    ACPI Video Driver
author:         Bruno Ducrot
retpoline:      Y
srcversion:     DB7078B5B5AFFDFE2241CAD
alias:          acpi*:LNXVIDEO:*
# 依赖output模块
depends:        output
vermagic:       2.6.32-754.el6.i686 SMP mod_unload modversions 686
parm:           brightness_switch_enabled:bool
parm:           use_native_backlight:int
```

linux中众多驱动程序，均为模块。内核如果没有自带驱动，则下载驱动源代码，手动编译成ko模块，且内核与内核模块必须完全匹配。

内核中的功能除了核心功能之外，在编译时，大多功能都有三种选择：

- 不编译，不使用此功能；
- 编译成内核模块，必须使用modprobe或者insmod装载；
- 编译进内核,属于内核一部分；

### 如何手动编译内核

1. make gconfig: Gnome桌面环境使用，需要安装图形开发库组：GNOME Software Development
2. make kconfig: KDE桌面环境使用，需要安装图形开发库
3. make menuconfig: 
4. make
5. make modules_install
6. make install

编译工具编译环境必须安装好(Development Tools, Development Libraries)

```shell
yum grouplist查询
[root@lmxlab ~]# cat /etc/yum.repos.d/local.repo
[centos]
name=centos
baseurl=file:///media/cdrom/Server
enabled=1
gpgcheck=0
[root@lmxlab ~]midkr /media/cdrom
[root@lmxlab ~]mount /dev/cdrom /media/cdrom
[root@lmxlab ~]yum groupinstall "Development Tools" "Development Libraries" -y
[root@localhost ~]# tar xf linux-2.6.28.10.tar.gz -C /usr/src


```

screen命令：
screen -ls: 显示已经建立的屏幕
screen: 直接打开一个新的屏幕
	Ctrl+a, d: 拆除屏幕
screen -r ID: 还原回某屏幕
exit: 退出





二次编译时清理，清理前，如果有需要，请备份配置文件.config：
make clean
make mrproper




grub-->kernel-->initrd-->ROOTFS(/sbin/init, /bin/bash)


mkinitrd  initrd文件路径  内核版本号

mkinitrd  /boot/initrd-`uname -r`.img  `uname -r`


${parameter#*word}
${parameter##*word}
              The word is expanded to produce a pattern just as in pathname expansion.  If the pattern matches the beginning of the value of
              parameter, then the result of the expansion is the expanded value of parameter with the shortest matching pattern  (the  ?..?.
              case)  or  the  longest  matching pattern (the ?..#?..case) deleted.  If parameter is @ or *, the pattern removal operation is
              applied to each positional parameter in turn, and the expansion is the resultant list.  If parameter is an array variable sub-
              scripted  with  @ or *, the pattern removal operation is applied to each member of the array in turn, and the expansion is the
              resultant list.

FILE=/usr/local/src
${FILE#*/}: usr/local/src
${FILE##*/}: src

${FILE%/*}: /usr/local
${FILE%%/*}:



${parameter%word*}
${parameter%%word*}
              The word is expanded to produce a pattern just as in pathname expansion.  If the pattern matches a  trailing  portion  of  the
              expanded  value  of  parameter, then the result of the expansion is the expanded value of parameter with the shortest matching
              pattern (the ?..?..case) or the longest matching pattern (the ?..%?..case) deleted.  If parameter  is  @  or  *,  the  pattern
              removal  operation  is applied to each positional parameter in turn, and the expansion is the resultant list.  If parameter is
              an array variable subscripted with @ or *, the pattern removal operation is applied to each member of the array in  turn,  and
              the expansion is the resultant list.


复制二进制程序及其依赖的库文件的脚本：
#!/bin/bash
#
DEST=/mnt/sysroot
libcp() {
  LIBPATH=${1%/*}
  [ ! -d $DEST$LIBPATH ] && mkdir -p $DEST$LIBPATH
  [ ! -e $DEST${1} ] && cp $1 $DEST$LIBPATH && echo "copy lib $1 finished."
}

bincp() {
  CMDPATH=${1%/*}
  [ ! -d $DEST$CMDPATH ] && mkdir -p $DEST$CMDPATH
  [ ! -e $DEST${1} ] && cp $1 $DEST$CMDPATH

  for LIB in  `ldd $1 | grep -o "/.*lib\(64\)\{0,1\}/[^[:space:]]\{1,\}"`; do
    libcp $LIB
  done
}

read -p "Your command: " CMD
until [ $CMD == 'q' ]; do
   ! which $CMD &> /dev/null && echo "Wrong command" && read -p "Input again:" CMD && continue
  COMMAND=` which $CMD | grep -v "^alias" | grep -o "[^[:space:]]\{1,\}"`
  bincp $COMMAND
  echo "copy $COMMAND finished."
  read -p "Continue: " CMD
done


/etc/rc.d/rc.sysdone脚本，可用于实现为微型的Linux系统关机
#!/bin/bash
#
sync
sleep 2
sync

mount | awk '{print $3}' | grep -v -E "\/(dev|proc|sys)?$" | sort -r | while read LINE; do
  umount -n -f $LINE
  [ $? -eq 0 ] && echo "Unmount $LINE finished." || echo "Can not unmount $LINE."
done

mount | awk '{print $3}' | while read LINE; do
  mount -n -o remount,ro $LINE
  [ $? -eq 0 ] && echo "Remount $LINE finished." || echo "Can not remount $LINE."
done

exec /sbin/halt -p




T_RED="\\033[1;31m"    # bold+red
T_GREEN="\\033[1;32m"  # bold+green
T_YELLOW="\\033[1;33m" # bold+yellow
T_BLUE="\\033[1;34m"   # bold+blue
T_CYAN="\\033[1;36m"   # cyan
T_BOLD="\\033[1;37m"   # bold+white
T_NORM="\\033[0;39m"   # normal




内核编译：
busybox: 

Kernel+ROOTFS()

kernel+initrd(ramdisk)

kernel+

busybox-->initrd

kernel+initrd(busybox)-->rootfs(busybox)

kenrel

RHEL5.8 + busybox(initrd) + rootfs(busybox)




查看本机硬件设备信息：
1、cat /proc/cpuinfo

2、lsusb

3、lspci

4、hal-device
	Hardware Abstract Layer

	
	
编译内核：
1、配置
make menuconfig
make gconfig
make kconfig
make oldconfig
make config

保存为.config

2、
make
make modules_install
make install
	
模块安装位置：/lib/modules/KERNEL_VERSION/	
	

如何实现部分编译：
1、只编译某子目录下的相关代码：
make dir/

make arch/
make drivers/net/

2、只编译部分模块
make M=drivers/net/

3、只编译某一模块
make drivers/net/pcnet32.ko

4、将编译完成的结果放置于别的目录中
make O=/tmp/kernel 

5、交叉编译
make ARCH=


如何编译busybox:

IDE: 
/dev/hda1: ext3  /boot
/dev/hda2: ext3 /



	
	
内核初始化：
	硬件探测
	装载驱动
	挂载根文件系统（rootfs）
	启动用户空间中的第一个进程init
	
	
http://youbest.cublog.cn



文件系统
进程管理
内存管理
网络管理
安全功能
驱动程序




Linux内核及编译

Linux系统安装和kickstart

故障排除

Kernel + initrd(busybox制作，提供ext3文件系统模块) + ROOTFS (busybox制作)

make arch/
	arch/x86/boot/bzImage
	
	硬件驱动：initrd
		initrd: 仅需要提供内核访问真正的根文件系统所在设备需要的驱动
			存储设备和文件系统相关的模块
		系统初始化rc.sysinit: 初始其它硬件的驱动程序；
		
	ROOTFS: busybox, init不支持运行级别
			/etc/inittab: 格式也不尽相同
		ash, hush
		bash

内核编译：
	make SUBDIR=arch/
	make arch/x86/


/boot/vmlinuz (ext3, IDE)


/mnt/boot: /dev/hda1
/mnt/sysroot: /dev/hda2


1、安装grub
2、提供内核
3、提供initrd
4、创建根文件系统


博客作业：

shell知识点总结及例子
RHEL5.8系统裁减：具有用户登录等功能
微型系统制作：具有IP地址、有虚拟终端、有主机名、能ssh远程登录；

